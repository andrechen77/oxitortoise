<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Wasm Debugger</title>
</head>

<body>
	<input type="text" id="model_name" placeholder="Model Name">
	<button id="load">Load</button>
	<button id="run_main">
		<pre>main()</pre>
	</button>
	<div id="view-container" style="height: 600px; width: 600px;"></div>

	<!-- <iframe id="nlw-frame" src="https://netlogoweb.org/standalone"
		style="width:1200px; height:1200px; border:1px solid #ccc;"></iframe> -->

	<!-- these are necessary to get `tortoise_require` to work -->
	<script src="tortoise-compiler.js"></script>
	<script src="tortoise-engine.js"></script>

	<script>
		var nlwFrame = document.getElementById('nlw-frame');
	</script>

	<script type="module">
		import ViewController from "http://localhost:9000/assets/javascripts/target/coffee-output/main/beak/widgets/draw/view-controller.js"

		const viewWidget = {
			fontSize: 11,
			dimensions: {
				// TODO get these from the model... somehow
				maxPxcor: 35,
				maxPycor: 35,
				minPxcor: -35,
				minPycor: -35,
				patchSize: 7,
				wrappingAllowedInX: false,
				wrappingAllowedInY: false,
			},
		};
		const container = document.getElementById('view-container');
		const viewController = new ViewController(container, viewWidget);

		async function instantiateWasm(modelName) {
			let wasmResult = null;
			let importObject = {
				env: {
					"write_to_console": (message, length) => {
						let mem = wasmResult.instance.exports.memory.buffer;
						let str = new TextDecoder().decode(new Uint8Array(mem, message, length));
						console.log(str);
					},
					"write_to_file": (namePtr, nameLength, bytesPtr, bytesLength) => {
						let mainMemory = wasmResult.instance.exports.memory;
						let bytes = new Uint8Array(mainMemory.buffer, bytesPtr, bytesLength);
						let name = new TextDecoder().decode(new Uint8Array(mainMemory.buffer, namePtr, nameLength));
						let blob = new Blob([bytes], { type: "application/octet-stream" });
						let url = URL.createObjectURL(blob);
						let a = document.createElement('a');
						a.href = url;
						a.download = name;
						document.body.appendChild(a);
						a.click();
						document.body.removeChild(a);
						URL.revokeObjectURL(url);
					},
					"instantiate_module": (auxModuleBufStart, auxModuleBufLen) => {
						try {
							console.log("instantiating module", auxModuleBufStart, auxModuleBufLen);

							let mainMemory = wasmResult.instance.exports["memory"];
							let auxModuleBuffer = new Uint8Array(mainMemory.buffer, auxModuleBufStart, auxModuleBufLen);

							// instantiate the auxiliary module
							let auxModule = new WebAssembly.Module(auxModuleBuffer);
							let auxInstance = new WebAssembly.Instance(auxModule, {
								"env": {
									...wasmResult.instance.exports
								}
							});

							return true;
						} catch (e) {
							console.error(e);
							return false;
						}
					},
					"grow_function_table": (numSlots) => {
						console.log("growing function table by ", numSlots);
						let mainTable = wasmResult.instance.exports["__indirect_function_table"];
						try {
							let latest_index = mainTable.grow(numSlots);
							return latest_index;
						} catch (e) {
							console.error(e);
							return -1;
						}
					},
					"visualize_update": (bytesPtr, bytesLength) => {
						let mainMemory = wasmResult.instance.exports.memory;
						let updateStr = new TextDecoder().decode(new Uint8Array(mainMemory.buffer, bytesPtr, bytesLength));
						let update = eval(`(${updateStr})`);
						viewController.update(update);
					}
				}
			}
			wasmResult = await WebAssembly.instantiateStreaming(fetch(`models/${modelName}/run.wasm`), importObject);
			return wasmResult;
		}

		var modelName = null;
		var globalWasm = null;

		async function load() {
			console.log("loading");
			modelName = document.getElementById('model_name').value;
			globalWasm = await instantiateWasm(modelName);
			console.log("loaded; the module is available at `var globalWasm`");
		}

		function getMem(addr, length = 4) {
			return new Uint8Array(globalWasm.instance.exports.memory.buffer, addr, length);
		}

		function runMain() {
			console.log("running main()");
			globalWasm.instance.exports.main();

			// loadAndEval("update_setup.txt").then((updateContent) => {
			// 	console.log(updateContent);
			// 	viewController.update(updateContent);
			// });
			// let nextTick = 0;
			// setInterval(() => {
			// 	let filename = `update_go_${nextTick}.txt`;
			// 	nextTick += 1;
			// 	let content = null;
			// 	loadAndEval(filename).then((updateContent) => {
			// 		console.log(`received`);
			// 		content = updateContent;
			// 	});
			// 	setTimeout(() => {
			// 		console.log("displaying")
			// 		if (content != null) {
			// 			viewController.update(content);
			// 		}
			// 	}, 1000);
			// }, 1000 / 10);
		}

		document.addEventListener('DOMContentLoaded', function () {
			document.getElementById('load').addEventListener('click', load);
			document.getElementById('run_main').addEventListener('click', runMain);
		});

		// Function to fetch and eval the contents of a file
		async function loadAndEval(filename) {
			try {
				const response = await fetch(`models/${modelName}/updates/${filename}`);
				if (!response.ok) {
					throw new Error('Failed to load file');
				}

				// Get the text content of the file
				const code = await response.text();

				return eval(`(${code})`);
			} catch (err) {
				console.error('Error:', err);
			}
		}
	</script>
</body>

</html>